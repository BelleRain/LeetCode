package Swordoffer.Math;

/**
 * @author mxy
 * @create 2022-11-03 0:12
 */

/**
 * 1～n 整数中 1 出现的次数
 * 输入一个整数 n ，求1～n这n个整数的十进制表示中1出现的次数。
 * 例如，输入12，1～12这些整数中包含1 的数字有1、10、11和12，1一共出现了5次。
 *
 * 示例 1：
 * 输入：n = 12
 * 输出：5
 *
 * 示例 2：
 * 输入：n = 13
 * 输出：6
 *
 * 限制：
 * 1 <= n < 2^31
 */
public class Offer43_1 {

    public static void main(String[] args) {
        Offer43_1 offer = new Offer43_1();
        System.out.println(offer.countDigitOne(12));
    }

    /**
     * 题解链接：https://leetcode.cn/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof/solution/mian-shi-ti-43-1n-zheng-shu-zhong-1-chu-xian-de-2/
     * 题解一：此题思路：逐位累加计算（累加每一数位上1的个数） (原文题解结合以下注释容易理解)
     *  一、类似于生活中常见的密码锁，几个滚轮的密码锁，固定其中一位，拨动其他位置，观察有几种情况
     *  此题中，可以理解为 在小于等于n的基础上，固定其中一位为1，拨动其他位置，查看有多少种可能，最后将逐位的情况进行累加
     *  二、 cur 当前位
     *  case 1: cur=0
     *      2  3   0  4
     *      千位和百位可以选00 01 02....22  十位可以取到1( 形如[00|01..|22]1[0-9] 都是<2304 ) 个位可以选0-9  共有 23 * 10 中排列
     *      当千位和百位取23,如果十位取1 那就是形如 231[0-9] > 2304,所以当千位和百位取23，十位只能能取0，个位取0-4即 2300 2301 2302 2303 2304
     *      但是2301不应该算进来，这个1是 单独  出现在个位的，要将其算入 cur == 1的情况中
     *      即 23*10
     * case 2: cur=1
     *    2  3  1  4
     *    千位和百位可以选 00 01 02....22  十位可以取到1 个位可以选0-9  共有 23 * 10 中排列
     *    当千位和百位取23,十位取1，个位可以去0-4 即 2310-2314共5个
     *    即 23 *10 + 4 +1
     * case 3: cur>1 即2-9
     *    2  3  2  4
     *    千位和百位可以选00 01 02....22  十位可以取到1(形如 [00|01...|22]1[0-9] 都是<2324) 个位可以选0-9  共有 23 * 10 中排列
     *    当千位和百位取23,十位取1，个位可以去0-9 即 2310-2319共10个 （其中2311，被计算了两次，分别是从个位和十位分析得到的1次）
     *    即 23 *10 + 1*10
     *
     * 复杂度分析：
     * 时间复杂度 O(logn) ： 循环内的计算操作使用 O(1) 时间；循环次数为数字 n 的位数，即 log_10{n},因此循环使用 O(logn) 时间。
     * 空间复杂度 O(1) ： 几个变量使用常数大小的额外空间。
     * @param n
     * @return
     */
    public int countDigitOne(int n) {
        //n为x个位数，记n的第i为ni,则可将n写为 n(x)n(x-1)...n2n1:
        //cur: ni为"当前位"
        //low: 低位，n(i-1)n(i-2)...n1
        //high: 高位，n(x)n(x-1)...n(i+2)n(i+1)
        //digit: 位因子，10^i ，个位：1，十位 10.
        int digit = 1 , res = 0;
        //high:高位，n
        int high = n/10 ,cur = n%10, low = 0;
        while (high != 0 || cur != 0){
            if (cur == 0) res += high * digit;
            else if (cur == 1) res += high * digit + low + 1;
            else res += (high + 1) * digit;
            low += cur * digit;
            cur = high % 10;
            high /= 10;
            digit *= 10;
        }
        return res;
    }

}
